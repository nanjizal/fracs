// Generated by Haxe 3.4.0 (git build development @ 4a40be3)
(function () { "use strict";
var HxOverrides = function() { };
HxOverrides.cca = function(s,index) {
	var x = s.charCodeAt(index);
	if(x != x) {
		return undefined;
	}
	return x;
};
HxOverrides.substr = function(s,pos,len) {
	if(len == null) {
		len = s.length;
	} else if(len < 0) {
		if(pos == 0) {
			len = s.length + len;
		} else {
			return "";
		}
	}
	return s.substr(pos,len);
};
var Std = function() { };
Std.parseInt = function(x) {
	var v = parseInt(x,10);
	if(v == 0 && (HxOverrides.cca(x,1) == 120 || HxOverrides.cca(x,1) == 88)) {
		v = parseInt(x);
	}
	if(isNaN(v)) {
		return null;
	}
	return v;
};
var Test = function() { };
Test.main = function() {
	var arr = fracs_Fracs.approximateFractions(0.012);
	var dist = Infinity;
	var dif;
	var l = arr.length;
	var fracFloat;
	var fracStore = arr[0];
	var _g1 = 0;
	while(_g1 < l) {
		var frac = arr[_g1++];
		if(frac.positive) {
			fracFloat = frac.numerator / frac.denominator;
		} else {
			fracFloat = -frac.numerator / frac.denominator;
		}
		dif = Math.abs(fracFloat - 0.012);
		if(dif < dist) {
			dist = dif;
			fracStore = frac;
		}
	}
	var frac1 = fracStore;
	var n = frac1.numerator;
	var d = frac1.denominator;
	console.log(n == 0 ? "0" : n == d ? "1" : d == 1 ? frac1.positive ? "" + n : "-" + n : frac1.positive ? "" + n + "/" + d : "-" + n + "/" + d);
	var all = fracs_Fracs.approximateFractions(-Math.PI);
	var l1 = all.length;
	var str = "";
	var _g11 = 0;
	while(_g11 < l1) {
		var this1 = all[_g11++];
		var n1 = this1.numerator;
		var d1 = this1.denominator;
		str = str + "\n" + (n1 == 0 ? "0" : n1 == d1 ? "1" : d1 == 1 ? this1.positive ? "" + n1 : "-" + n1 : this1.positive ? "" + n1 + "/" + d1 : "-" + n1 + "/" + d1);
	}
	console.log(" all " + str);
	var p;
	console.log("from 0 -> 2pi");
	var i = 0.;
	while(i < 2 * Math.PI + Math.PI / 10) {
		var a = (i + Math.PI) % (2 * Math.PI);
		p = a >= 0 ? a - Math.PI : a + Math.PI;
		var f = p / Math.PI;
		var arr1 = fracs_Fracs.approximateFractions(f);
		var dist1 = Infinity;
		var dif1;
		var l2 = arr1.length;
		var fracFloat1;
		var fracStore1 = arr1[0];
		var _g12 = 0;
		while(_g12 < l2) {
			var frac2 = arr1[_g12++];
			if(frac2.positive) {
				fracFloat1 = frac2.numerator / frac2.denominator;
			} else {
				fracFloat1 = -frac2.numerator / frac2.denominator;
			}
			dif1 = Math.abs(fracFloat1 - f);
			if(dif1 < dist1) {
				dist1 = dif1;
				fracStore1 = frac2;
			}
		}
		var frac3 = fracStore1;
		var n2 = frac3.numerator;
		var d2 = frac3.denominator;
		var out = n2 == 0 ? "0" : n2 == d2 ? "1" : d2 == 1 ? frac3.positive ? "" + n2 : "-" + n2 : frac3.positive ? "" + n2 + "/" + d2 : "-" + n2 + "/" + d2;
		if(!(frac3.denominator == 10 || out == "0" || out == "1")) {
			var dom = Math.round(frac3.value * 10);
			var numerator = dom;
			var positive = true;
			var value = null;
			var this2;
			var numNeg = dom < 0;
			if(value == null) {
				value = dom / 10;
			}
			if(numNeg) {
				positive = false;
				if(numNeg) {
					numerator = -dom;
				}
			}
			this2 = { numerator : numerator, denominator : 10, positive : positive, value : value};
			var frac4 = this2;
			var n3 = frac4.numerator;
			var d3 = frac4.denominator;
			out = n3 == 0 ? "0" : n3 == d3 ? "1" : d3 == 1 ? frac4.positive ? "" + n3 : "-" + n3 : frac4.positive ? "" + n3 + "/" + d3 : "-" + n3 + "/" + d3;
		}
		console.log(out + " pi");
		i += Math.PI / 10;
	}
	console.log("from -pi to pi");
	i = -Math.PI;
	while(i < Math.PI + Math.PI / 10) {
		var a1 = (i + Math.PI) % (2 * Math.PI);
		p = a1 >= 0 ? a1 - Math.PI : a1 + Math.PI;
		var f1 = p / Math.PI;
		var arr2 = fracs_Fracs.approximateFractions(f1);
		var dist2 = Infinity;
		var dif2;
		var l3 = arr2.length;
		var fracFloat2;
		var fracStore2 = arr2[0];
		var _g13 = 0;
		while(_g13 < l3) {
			var frac5 = arr2[_g13++];
			if(frac5.positive) {
				fracFloat2 = frac5.numerator / frac5.denominator;
			} else {
				fracFloat2 = -frac5.numerator / frac5.denominator;
			}
			dif2 = Math.abs(fracFloat2 - f1);
			if(dif2 < dist2) {
				dist2 = dif2;
				fracStore2 = frac5;
			}
		}
		var frac6 = fracStore2;
		var n4 = frac6.numerator;
		var d4 = frac6.denominator;
		console.log((n4 == 0 ? "0" : n4 == d4 ? "1" : d4 == 1 ? frac6.positive ? "" + n4 : "-" + n4 : frac6.positive ? "" + n4 + "/" + d4 : "-" + n4 + "/" + d4) + " pi");
		i += Math.PI / 10;
	}
	var arr3 = fracs_Fracs.approximateFractions(3.14159265358979);
	var dist3 = Infinity;
	var dif3;
	var l4 = arr3.length;
	var fracFloat3;
	var fracStore3 = arr3[0];
	var _g14 = 0;
	while(_g14 < l4) {
		var frac7 = arr3[_g14++];
		if(frac7.positive) {
			fracFloat3 = frac7.numerator / frac7.denominator;
		} else {
			fracFloat3 = -frac7.numerator / frac7.denominator;
		}
		dif3 = Math.abs(fracFloat3 - 3.14159265358979);
		if(dif3 < dist3) {
			dist3 = dif3;
			fracStore3 = frac7;
		}
	}
	var pi = fracStore3;
	var arr4 = fracs_Fracs.approximateFractions(1.414213562);
	var dist4 = Infinity;
	var dif4;
	var l5 = arr4.length;
	var fracFloat4;
	var fracStore4 = arr4[0];
	var _g15 = 0;
	while(_g15 < l5) {
		var frac8 = arr4[_g15++];
		if(frac8.positive) {
			fracFloat4 = frac8.numerator / frac8.denominator;
		} else {
			fracFloat4 = -frac8.numerator / frac8.denominator;
		}
		dif4 = Math.abs(fracFloat4 - 1.414213562);
		if(dif4 < dist4) {
			dist4 = dif4;
			fracStore4 = frac8;
		}
	}
	var sqrt_2 = fracStore4;
	var arr5 = fracs_Fracs.approximateFractions(1.618033988);
	var dist5 = Infinity;
	var dif5;
	var l6 = arr5.length;
	var fracFloat5;
	var fracStore5 = arr5[0];
	var _g16 = 0;
	while(_g16 < l6) {
		var frac9 = arr5[_g16++];
		if(frac9.positive) {
			fracFloat5 = frac9.numerator / frac9.denominator;
		} else {
			fracFloat5 = -frac9.numerator / frac9.denominator;
		}
		dif5 = Math.abs(fracFloat5 - 1.618033988);
		if(dif5 < dist5) {
			dist5 = dif5;
			fracStore5 = frac9;
		}
	}
	var goldenRatio = fracStore5;
	var arr6 = fracs_Fracs.approximateFractions(365.2422);
	var dist6 = Infinity;
	var dif6;
	var l7 = arr6.length;
	var fracFloat6;
	var fracStore6 = arr6[0];
	var _g17 = 0;
	while(_g17 < l7) {
		var frac10 = arr6[_g17++];
		if(frac10.positive) {
			fracFloat6 = frac10.numerator / frac10.denominator;
		} else {
			fracFloat6 = -frac10.numerator / frac10.denominator;
		}
		dif6 = Math.abs(fracFloat6 - 365.2422);
		if(dif6 < dist6) {
			dist6 = dif6;
			fracStore6 = frac10;
		}
	}
	var earthTropicalYear = fracStore6;
	var n5 = pi.numerator;
	var d5 = pi.denominator;
	console.log(n5 == 0 ? "0" : n5 == d5 ? "1" : d5 == 1 ? pi.positive ? "" + n5 : "-" + n5 : pi.positive ? "" + n5 + "/" + d5 : "-" + n5 + "/" + d5);
	var n6 = sqrt_2.numerator;
	var d6 = sqrt_2.denominator;
	console.log(n6 == 0 ? "0" : n6 == d6 ? "1" : d6 == 1 ? sqrt_2.positive ? "" + n6 : "-" + n6 : sqrt_2.positive ? "" + n6 + "/" + d6 : "-" + n6 + "/" + d6);
	var n7 = goldenRatio.numerator;
	var d7 = goldenRatio.denominator;
	console.log(n7 == 0 ? "0" : n7 == d7 ? "1" : d7 == 1 ? goldenRatio.positive ? "" + n7 : "-" + n7 : goldenRatio.positive ? "" + n7 + "/" + d7 : "-" + n7 + "/" + d7);
	var n8 = earthTropicalYear.numerator;
	var d8 = earthTropicalYear.denominator;
	console.log(n8 == 0 ? "0" : n8 == d8 ? "1" : d8 == 1 ? earthTropicalYear.positive ? "" + n8 : "-" + n8 : earthTropicalYear.positive ? "" + n8 + "/" + d8 : "-" + n8 + "/" + d8);
	var i1 = "1/2".indexOf("/");
	var frac11;
	if(i1 != -1) {
		var numerator1 = Std.parseInt(HxOverrides.substr("1/2",0,i1));
		var denominator = Std.parseInt(HxOverrides.substr("1/2",i1 + 1,"1/2".length));
		var positive1 = true;
		var value1 = null;
		var this3;
		var numNeg1 = numerator1 < 0;
		var denoNeg = denominator < 0;
		if(value1 == null) {
			value1 = numerator1 / denominator;
		}
		if(numNeg1 || denoNeg) {
			if(!(numNeg1 && denoNeg)) {
				positive1 = false;
			}
			if(numNeg1) {
				numerator1 = -numerator1;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		this3 = { numerator : numerator1, denominator : denominator, positive : positive1, value : value1};
		frac11 = this3;
	} else {
		var f2 = parseFloat("1/2");
		var arr7 = fracs_Fracs.approximateFractions(f2);
		var dist7 = Infinity;
		var dif7;
		var l8 = arr7.length;
		var fracFloat7;
		var fracStore7 = arr7[0];
		var _g18 = 0;
		while(_g18 < l8) {
			var frac12 = arr7[_g18++];
			if(frac12.positive) {
				fracFloat7 = frac12.numerator / frac12.denominator;
			} else {
				fracFloat7 = -frac12.numerator / frac12.denominator;
			}
			dif7 = Math.abs(fracFloat7 - f2);
			if(dif7 < dist7) {
				dist7 = dif7;
				fracStore7 = frac12;
			}
		}
		frac11 = fracStore7;
	}
	var frac13 = frac11;
	p = (frac13.positive ? frac13.numerator / frac13.denominator : -frac13.numerator / frac13.denominator) * Math.PI;
	console.log(p);
	var f3 = p / Math.PI;
	var arr8 = fracs_Fracs.approximateFractions(f3);
	var dist8 = Infinity;
	var dif8;
	var l9 = arr8.length;
	var fracFloat8;
	var fracStore8 = arr8[0];
	var _g19 = 0;
	while(_g19 < l9) {
		var frac14 = arr8[_g19++];
		if(frac14.positive) {
			fracFloat8 = frac14.numerator / frac14.denominator;
		} else {
			fracFloat8 = -frac14.numerator / frac14.denominator;
		}
		dif8 = Math.abs(fracFloat8 - f3);
		if(dif8 < dist8) {
			dist8 = dif8;
			fracStore8 = frac14;
		}
	}
	var frac15 = fracStore8;
	var n9 = frac15.numerator;
	var d9 = frac15.denominator;
	console.log((n9 == 0 ? "0" : n9 == d9 ? "1" : d9 == 1 ? frac15.positive ? "" + n9 : "-" + n9 : frac15.positive ? "" + n9 + "/" + d9 : "-" + n9 + "/" + d9) + "pi");
	console.log(p * 180 / Math.PI);
	var arr9 = fracs_Fracs.approximateFractions(0.333333333333333);
	var dist9 = Infinity;
	var dif9;
	var l10 = arr9.length;
	var fracFloat9;
	var fracStore9 = arr9[0];
	var _g110 = 0;
	while(_g110 < l10) {
		var frac16 = arr9[_g110++];
		if(frac16.positive) {
			fracFloat9 = frac16.numerator / frac16.denominator;
		} else {
			fracFloat9 = -frac16.numerator / frac16.denominator;
		}
		dif9 = Math.abs(fracFloat9 - 0.333333333333333);
		if(dif9 < dist9) {
			dist9 = dif9;
			fracStore9 = frac16;
		}
	}
	var third = fracStore9;
	var n10 = third.numerator;
	var d10 = third.denominator;
	console.log(n10 == 0 ? "0" : n10 == d10 ? "1" : d10 == 1 ? third.positive ? "" + n10 : "-" + n10 : third.positive ? "" + n10 + "/" + d10 : "-" + n10 + "/" + d10);
};
var fracs__$Fraction_FractionArray_$Impl_$ = {};
fracs__$Fraction_FractionArray_$Impl_$.add = function(this1,val) {
	this1[this1.length] = val;
};
var fracs_Fracs = function() { };
fracs_Fracs.approximateFractions = function(f) {
	var positive = f <= 0 ? false : true;
	var numerators = [0,1];
	var denominators = [1,0];
	var f2 = f <= 0 ? -f : f;
	var fStr = f2 == null ? "null" : "" + f2;
	var digits = "";
	var ix = fStr.indexOf(".");
	if(ix == -1) {
		digits = fStr;
	} else if(ix == 0) {
		digits = HxOverrides.substr(fStr,1,fStr.length);
	} else if(ix < fStr.length) {
		digits = HxOverrides.substr(fStr,0,ix) + HxOverrides.substr(fStr,ix + 1,fStr.length);
	}
	var L2 = f2;
	var numIntDigits = (L2 == null ? "null" : "" + L2).length;
	if(L2 == 0) {
		numIntDigits = 0;
	}
	var numDigitsPastDecimal = digits.length - numIntDigits;
	var i = numDigitsPastDecimal;
	var L = parseFloat(digits);
	while(i > 0 && L % 2 == 0) {
		L /= 2;
		--i;
	}
	i = numDigitsPastDecimal;
	while(i > 0 && L % 5 == 0) {
		L /= 5;
		--i;
	}
	var maxNumerator = L;
	var d2 = f2;
	var calcD;
	var prevCalcD = null;
	var arrFraction = [];
	var _g = 2;
	while(_g < 1000) {
		var i1 = _g++;
		var L21 = Math.floor(d2);
		numerators[i1] = L21 * numerators[i1 - 1] + numerators[i1 - 2] | 0;
		if(Math.abs(numerators[i1]) > maxNumerator) {
			break;
		}
		denominators[i1] = L21 * denominators[i1 - 1] + denominators[i1 - 2] | 0;
		calcD = numerators[i1] / denominators[i1];
		if(calcD == prevCalcD) {
			break;
		}
		var numerator = numerators[i1];
		var denominator = denominators[i1];
		var positive1 = positive;
		var value = f;
		var this1;
		var numNeg = numerator < 0;
		var denoNeg = denominator < 0;
		if(f == null) {
			if(positive1) {
				value = numerator / denominator;
			} else {
				value = -numerator / denominator;
			}
		}
		if(numNeg || denoNeg) {
			if(!(numNeg && denoNeg)) {
				positive1 = !positive1;
			}
			if(numNeg) {
				numerator = -numerator;
			}
			if(denoNeg) {
				denominator = -denominator;
			}
		}
		this1 = { numerator : numerator, denominator : denominator, positive : positive1, value : value};
		fracs__$Fraction_FractionArray_$Impl_$.add(arrFraction,this1);
		if(calcD == f2) {
			break;
		}
		prevCalcD = calcD;
		d2 = 1 / (d2 - L21);
	}
	return arrFraction;
};
Test.main();
})();
